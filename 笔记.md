## zookeeper
一种分布式系统的中间件，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。因为分布式系统需要节点管理，所以有zookeeper。

核心：节点，监听。
- Znode节点的数据变化
- 子节点的增减变化

### 统一配置服务
比如我们现在有三个系统A、B、C，他们有三份配置，分别是ASystem.yml、BSystem.yml、CSystem.yml，然后，这三份配置又非常类似，很多的配置项几乎都一样。

此时，如果我们要改变其中一份配置项的信息，很可能其他两份都要改。并且，改变了配置项的信息很可能就要重启系统。

于是，我们希望把ASystem.yml、BSystem.yml、CSystem.yml相同的配置项抽取出来成一份公用的配置common.yml，并且即便common.yml改了，也不需要系统A、B、C重启。

做法：我们可以将common.yml这份配置放在ZooKeeper的Znode节点中，系统A、B、C监听着这个Znode节点有无变更，如果变更了，及时响应。

![](./pic/eg0.jpg)

### 统一命名服务

统一命名服务的理解其实跟域名一样，是我们为这某一部分的资源给它取一个名字，别人通过这个名字就可以拿到对应的资源。

比如说，现在我有一个域名www.java3y.com，但我这个域名下有多台机器：

192.168.1.1

192.168.1.2

192.168.1.3

192.168.1.4

别人访问www.java3y.com即可访问到我的机器，而不是通过IP去访问。
![](./pic/eg1.jpg)

### 分布式锁
![](./pic/eg2.jpg)
- 系统A拿到/locks节点下的所有子节点，经过比较，发现自己(id_000000)，是所有子节点最小的。所以得到锁
- 系统B拿到/locks节点下的所有子节点，经过比较，发现自己(id_000002)，不是所有子节点最小的。所以监听比自己小1的节点id_000001的状态
- 系统C拿到/locks节点下的所有子节点，经过比较，发现自己(id_000001)，不是所有子节点最小的。所以监听比自己小1的节点id_000000的状态

等到系统A执行完操作以后，将自己创建的节点删除(id_000000)。通过监听，系统C发现id_000000节点已经删除了，发现自己已经是最小的节点了，于是顺利拿到锁

### 集群状态
![](./pic/eg4.jpg)
只要系统A挂了，那/groupMember/A这个节点就会删除，通过监听groupMember下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理)

除了能够感知节点的上下线变化，ZooKeeper还可以实现动态选举Master的功能。(如果集群是主从架构模式下)

原理也很简单，如果想要实现动态选举Master的功能，Znode节点的类型是带顺序号的临时节点(EPHEMERAL_SEQUENTIAL)就好了。

Zookeeper会每次选举最小编号的作为Master，如果Master挂了，自然对应的Znode节点就会删除。然后让新的最小编号作为Master，这样就可以实现动态选举的功能了。

## keepalived
Keepalived一个基于VRRP（Virtual Router Redundancy Protocol）协议来实现的 LVS（Linux virtual server） 服务高可用方案，可以利用其来解决单点故障。一个LVS服务会有2台服务器运行Keepalived，一台为主服务器（MASTER），一台为备份服务器（BACKUP），但是对外表现为一个虚拟IP，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。

冗余+故障自动发现转移

keepalived工作原理是什么？怎么保证高可用呢？ - 码海的回答 - 知乎
https://www.zhihu.com/question/34822368/answer/2126403039

## Ceph

Ceph是一个统一的**分布式文件存储系统**，设计初衷是提供较好的性能、可靠性和可扩展性。

### 特点

Ceph的特点很多，主要有如下几个方面的特点： 

1. 其摒弃传统的集中式存储元数据寻址的方式，采用CRUSH算法，数据分布均衡，没有单点故障。举个栗子：就像上面的粮仓和粮食的说明，现在张三来存100斤粮食，管理员将其存放在A仓库的B区，然后在小本本记下这个地址，这里的小本本就是元数据。当张三来取粮食的时候，管理员拿出小本本查看粮食的存放位置，然后找到粮食。是不是挺好。但是大家想想，如果这个小本本丢了，会怎么样？ 是不是张三的粮食就找不到了。这样就存在一个重大的隐患。这个隐患的学名叫做单点故障，单点故障的意思是，某一个节点出现故障将会导致集群整个不可用。当然，我们也可以通过用多个小本本同时记录，规避一台元数据服务宕机导致的单点故障。但是，这种方式无疑增加了元数据的维护成本。而Ceph则完全摒弃了元数据寻址的方式，直接通过[CRUSH算法](https://zhuanlan.zhihu.com/p/63725901)的方式来计算文件的位置，使数据可以均衡分布同时也避免了单点故障的问题。 
2.  考虑了容灾域的隔离，能够实现各类负载副本放置规则。同样的还是以粮仓为例子。当一个仓库着火了，我们可以通过隔断门将其与其他正常的仓库隔离。避免影响到其他正常的仓库。 
3.  能够支持上千个存储节点的规模，支持TB和PB级别的数据。这句话的意思就更好理解了，一句话，就是Ceph的能存储的数据特别多，规模也很大。 
4.  扩展灵活，就是说支持动态的增加存储节点。换言之就是可以客户端无感知的情况下增加存储节点。不影响现有的业务。
5.  副本数可以灵活控制，默认情况下Ceph的副本数是3个，我们可以在配置文件中更改副本的数量。

## 虚拟化

是一种资源管理技术，是将计算机的各种实体资源（CPU、内存、磁盘空间、网络适配器等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和资料存储。

早期服务器只能运行特定的操作系统和程序，其他的不兼容。公司为了运行新业务，只能不断购买新的服务器，一方面，成本越来越高，运维麻烦；另一方面，算力资源大量浪费。这正是20年多前企业数据中心的普遍现状。

什么是虚拟化？我们举一个通俗的例子。假设你有3台服务器，每1台固定跑1个业务。这个时候，每台服务器使用了30%的算力，剩余的70%处于闲置状态。

![](./pic/虚拟化0.jpg)

虚拟化是如何解决问题的？我们来看一下这张图，服务器的底层是硬件，包括CPU、GPU、IO（输入输出设备）、内存、磁盘和网卡等，统称为“硬件资源”，往上是操作系统和程序。虚拟化技术相当于在硬件和操作系统之间，增加了一个虚拟化平台，屏蔽了硬件和操作系统之间的兼容性问题。这个时候，不管硬件是否兼容，我们都能安装多个操作系统，每个系统运行不同的业务。底层硬件变成一个共享“资源池”，每个操作系统需要多大的CPU、内存、硬盘，由虚拟化平台按需分配。运行在虚拟化平台上的操作系统，我们叫它虚拟机。

原本单台服务器只能发挥30%的性能，现在1台服务器可以运行多个操作系统，服务器性能可以发挥到60%，甚至90%。假设以前需要100台服务器，现在可能只需要30多台，硬件成本大幅度降低，而且机房的电费、散热和维护等成本也随之降低。

简单来说，虚拟化允许在一台服务器上同时运行多个操作系统，能够提升资源使用效率。

虚拟化是云计算的基础：

- 提高资源利用率：虚拟化技术可以将一台物理服务器划分为多个虚拟机，每个虚拟机拥有独立的操作系统和应用程序，可以在不同的虚拟机之间**灵活地分配计算资源**，从而提高了物理服务器的资源利用率。

- 实现快速部署和弹性伸缩：通过虚拟化技术，可以快速创建和销毁虚拟机，实现应用程序的**快速部署和弹性伸缩**。例如，当应用程序需要更多计算资源时，可以通过自动化的方式快速创建新的虚拟机，并将应用程序部署到新的虚拟机上。

- 提高安全性：虚拟化技术可以将不同的虚拟机隔离开来，每个虚拟机拥有独立的操作系统和应用程序，可以提高**安全性**，避免应用程序之间的相互干扰和攻击。

- 简化管理和维护：通过虚拟化技术，可以将虚拟机的管理和维护与物理服务器分离，简化了管理和维护的工作量。例如，可以通过自动化的方式对虚拟机进行管理、备份和恢复操作，**提高了运维效率**。

- 支持多租户：虚拟化技术可以将一台物理服务器划分为多个虚拟机，每个虚拟机拥有独立的操作系统和应用程序，可以为不同的租户提供独立的计算资源。这样可以实现多租户的支持，提高了云计算平台的**灵活性和可扩展性**。

虚拟化分为硬件虚拟化和容器技术。

### 硬件虚拟化

虚拟机，就是用的硬件虚拟化技术。每个虚拟机需要一个完整的操作系统，才能装应用。但是，如果每次发布应用，都得搞一个完整操作系统和附带的依赖环境，会很繁琐。

虚拟机需要虚拟硬件，然后再装操作系统和应用。

强调安全、隐私性。

### 容器

容器是用来装东西的地方，就像书包可以装文具、衣柜可以放衣服一样。我们现在说的容器，里面存放的是应用程序，以及程序运行所依赖的系统环境。通过容器技术，我们可以把应用和依赖的环境打包，打包之后移植到另一个主机上，还能正常运行。

容器直接使用原来的操作系统，只需要打包应用和依赖的环境即可，应用共享相同的操作系统。因此，容器更加轻量化，容易迁移、部署方便、启动速度更快、资源占用也更小。而且，容器可以实现标准化，就像集装箱，能按统一的规范来做。

如果一个应用在不同操作系统上不兼容，使用容器如何实现？

> 容器确实包含应用程序所需的操作系统组件，但这些组件并不一定包括完整的操作系统，而是针对特定的操作系统版本和发行版进行优化，以满足应用程序的运行环境和依赖项。
>
> 当容器共享主机操作系统时，容器中的应用程序和操作系统组件将与主机操作系统的内核和其他系统资源共享，这使得容器具有更高的资源利用率和灵活性。但同时，这也意味着容器中的应用程序和操作系统组件需要与主机操作系统相兼容，以避免在容器中运行时出现问题。
>
> 例如，如果容器运行在 Linux 主机上，那么容器中的应用程序和操作系统组件需要兼容 Linux 内核和其他系统组件。如果容器运行在 Windows 主机上，那么容器中的应用程序和操作系统组件需要兼容 Windows 内核和其他系统组件。如果容器中的应用程序和操作系统组件与主机操作系统不兼容，可能会导致应用程序无法启动或运行异常。
>
> 此外，即使容器中的应用程序和操作系统组件在不同操作系统上都兼容，也不能保证应用程序在不同操作系统上的行为完全相同。因为不同操作系统之间可能存在差异，例如文件系统布局、网络配置、系统调用等等，这些差异可能会影响应用程序的行为。因此，在将应用程序从一个操作系统迁移到另一个操作系统时，还需要进行适当的测试和验证，以确保应用程序在新的操作系统中能够正常工作。
>
> 总的来说，容器共享主机操作系统的特性可能会导致容器中的应用程序在不同操作系统上运行不兼容，这需要在容器设计和部署时进行适当的考虑和测试，以确保应用程序能够正常运行。容器中的操作系统组件可以帮助应用程序在共享主机操作系统的同时提供所需的环境和依赖项，但同时也需要与主机操作系统相兼容，以避免出现问题。

强调轻量级，迅速。

## Docker

一种容器技术，无需像虚拟机那样加载全部的操作系统。容器是一种通用技术，docker只是其中的一种实现。

docker是一个用Go语言实现的开源项目，可以让我们方便的创建和使用容器，docker将程序以及程序所有的依赖都打包到docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器就好比集装箱，容器所处的操作系统环境就好比货船或港口，**程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系**。

因此我们可以看到docker可以屏蔽环境差异，也就是说，只要你的程序打包到了docker中，那么无论运行在什么环境下程序的行为都是一致的，程序员再也无法施展表演才华了，**不会再有“在我的环境上可以运行”**，真正实现“build once, run everywhere”。

此外docker的另一个好处就是**快速部署**，这是当前互联网公司最常见的一个应用场景，一个原因在于容器启动速度非常快，另一个原因在于只要确保一个容器中的程序正确运行，那么你就能确信无论在生产环境部署多少都能正确运行。

docker中有这样几个概念：

- dockerfile
- image
- container

实际上可以简单的把image理解为可执行程序，container就是运行起来的进程。

那么写程序需要源代码，那么“写”image就需要dockerfile，dockerfile就是image的源代码，docker就是"编译器"。

因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。

docker的常用命令：

- docker build

  当我们写完dockerfile交给docker“编译”时使用这个命令，那么client在接收到请求后转发给docker daemon，接着docker daemon根据dockerfile创建出“可执行程序”image。

  ![](./pic/docker_build.jpg)

- docker run

  有了“可执行程序”image后就可以运行程序了，接下来使用命令docker run，docker daemon接收到该命令后找到具体的image，然后加载到内存开始执行，image执行起来就是所谓的container。

  ![](.\pic\docker_run.jpg)

- docker pull

  我们之前说过，docker中image的概念就类似于“可执行程序”，我们可以从哪里下载到别人写好的应用程序呢？很简单，那就是APP Store，即应用商店。与之类似，既然image也是一种“可执行程序”，那么有没有"Docker Image Store"呢？答案是肯定的，这就是Docker Hub，docker官方的“应用商店”，你可以在这里下载到别人编写好的image，这样你就不用自己编写dockerfile了。

  docker registry 可以用来存放各种image，公共的可以供任何人下载image的仓库就是docker Hub。那么该怎么从Docker Hub中下载image呢，就是这里的docker pull命令了。

  因此，这个命令的实现也很简单，那就是用户通过docker client发送命令，docker daemon接收到命令后向docker registry发送image下载请求，下载后存放在本地，这样我们就可以使用image了。

  ![](./pic/docker_pull.jpg)
